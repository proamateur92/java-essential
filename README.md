# 자바의 정석 내용 정리

## 1장

### 1-1. 자바란?

- 프로그래밍 언어
- 컴퓨터 프로그램(애플리케이션)을 만드는데 사용
- 실행환경 (JRE) + 개발도구 (JDK) + 라이브러리 (API)
- 쉽고 빠르게 애플리케이션 개발 가능

>

### 1-2. 자바가 쓰이는 곳

- pc application
- web application
- mobile application
- big data 하둡 등
- game (minecraft), 과학, 소형기기 등

>

### 1-3. 왜 자바인가?

- 객체지향 + 함수형
>

### 1-4. 자바의 특징

- 객체지향 언어 (프로그래밍 언어 + 객체지향 개념) 
- 자동 메모리 관리 (가비지컬렉터 GC)
- 멀티 쓰레드 지원 (하나의 프로그램에서 여러개 동작 가능, 채팅하며 파일 전송 기능 등)
- 라이브러리 지원 => 쉽게 개발 가능하다
- 운영체제에 독립적

>

### 1-5. 자바 가상 머신 (JVM)

- 여러 운영체제에서 사용 가능하도록 한다.
- 소프트웨어로 만들어진 가상 컴퓨터.


>하나의 자바 app은 JVM으로 구동되는 경우 모든 운영체제 위해서 사용될 수 있다.
JAVA application <-> JVM <-> OS <-> 하드웨어

>일반적인 application은 특정 운영체제에서 사용 가능하도록 만들어진다.
window application의 경우 window 환경에서 사용 가능하며 메킨토시 또는 리눅스 
운영체제에서 사용되기 위해서는 해당 app을 운영체제에 맞게 수정하여야 한다.


### 1-6. 자바 api 문서 사용법  

> Java API란?
Java로 프로그램을 만드는데 필요한 주요 기능을 미리 만들어서 제공
> https://docs.oracle.com/en/java/javase/11/docs/api/

### 1-7. 자바 프로그램 작성, 실행 해보기

> 자바 프로그램 작성 (.java) -> 컴파일 javac.exe(자바 컴파일러) -> class 파일 생성 (JVM이 이해할 수 있다.) -> java.exe (자바 인터프리터)로 자바 프로그램 실행 

1. 해당 파일이 위치한 디렉토리로 이동
2. javac 파일명 (Hello.java) 명령어를 통해 javac.exe (자바 컴파일러)로 컴파일
3. jdk1.8 > javac.exe 위치를 지정해주여야 함
3-1. 일일이 javac 의 경로를 명령어에 사용하지 않고 환경변수에 지정해주도록 한다.
3-2. 환경변수 > path에 경로를 추가하면 파일의 경로를 찾지 못하면 path에 등록된 환경변수의
가장 위부터 찾게 된다.
4. 3을 거쳐 컴퓨터가 이해할 수 있는 class 파일 = 바이너리 파일, 이진 파일 생성
4-1. type Hello.class 
4-2. type Hello.java (텍스트 파일명) - 사람이 이해할 수 있는 코드
5. 자바 파일 실행 java Hello(class파일명) - 이때에는 확장자를 쓰지 않는다.
5-1. java.exe (인터프리터)는 자바 프로그램(class파일)을 실행한다.

  
  
- 클래스 - 자바 프로그램의 단위. 자바 프로그램은 클래스들로 구성된다.

```
 class 클래스 이름 {
	/* 모든 문장은 클래스의 {} 안에 있어야 한다. */
 }
```

<br>

- main 메서드 - 자바 프로그램의 시작점. 이 메서드 없이 실행 불가 

```
class 클래스 이름 {
	public void main (String[] args) { 
		/* 실행한 문장을 넣는다. */
	}
 }
```

<br>
 
  
## 6장 객체지향 언어 OOP

> 빠른 변화로 인한 소프트웨어의 위기의 해결책으로 절차적 언어에서 객체지향으로 변경
> 코드 재사용성이 높다. 유지보수 용이. 중복 코드 제거
> 객체지향언어란 프로그래밍언어와 객체지향개념을 더한 것

<br>

- 캡슐화
- 상속
- 추상화
- 다형성

### 6-2. 클래스와 객체

- 클래스란? 객체를 정의해 놓은 것. 객체를 생성하는데 사용한다.
- 객체란? 실제로 존재하는 것으로 사물 또는 개념. 객체가 가지고 있는 기능과 속성에 따라 다르다.

- 클래스 
	- 제품 설계도
	- TV 설계도
	- 붕어빵 기계

- 객체
	- 제품
	- TV
	- 붕어빵

### 6-3. 객체의 구성요소 - 속성(변수)과 기능(메서드)

> TV의 속성. 크기, 길이, 높이, 색상, 볼륨, 채널 등
> TV의 기능. 전원 on / off, 볼륨 높이기, 낮추기 채널 변경하기 등

<br>

```
class Tv {
	String color;
	boolean power;
	int channel;
	
	void power() { power = !power; }
	void channelUp() { channel++; }
	void channelDown() { channel--; }
}
```

### 6-4 객체와 인스턴스

- 객체: 모든 인스턴스를 대표하는 일반적 용어
- 인스턴스: 특정 클래스로부터 생성된 객체 (ex: Tv인스턴스)
	
<br>
	
> 클래스를 인스턴스화(생성)하여 인스턴스(객체)를 만든다.
> 클래스는 객체를 생성하기 위해 필요하다. 객체를 사용하려면 객체가 있어야 하고 속성과 기능을 가져야 한다.

### 6-5 하나의 소스 파일에 여러 클래스 작성

> public class가 있는 경우 소스파일의 이름과 public class 명이 일치해야 한다.
> public class가 없는 경우. 소스파일의 이름은 class 명과 일치하면 된다.
>
> class 명이 소스파일 명과 일치하지 않는 경우 에러가 발생하지 않지만 해당 소스 파일이 실행되지 않는다.
>
> 하나의 소스 파일에는 하나의 클래스만 작성하는 것이 바람직하다.

### 6-6 객체의 생성과 사용

#### 1. 객체의 생성

```
// 클래스명 변수명;		클래스의 객체를 참조하기 위한 참조변수를 선언.
// 변수명 = new 클래스명();	클래스의 객체를 생성하고 객체의 주소를 참조변수에 저장.

Tv t;				// Tv 클래스 타입의 참조변수 t를 선언. 참조변수는 리모컨과 같다.
t = new Tv();			// Tv 인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장. 리모컨과 객체를 연결한다는 의미.
```

<br>

#### 2. 객체의 사용 (변수와 메서드)

```
t.channel = 7;
t.cannelDown();
System.out.println("현재 채널은 " + t.channel + " 입니다.");
```

> 객체를 사용하기 위한 순서
> 클래스 작성 -> 객체 생성 -> 객체 사용 

### 6-7 객체의 생성과 사용 예제

```
Tv t1 = new Tv();
Tv t2 = new Tv();

t2 = t1;
```

<br>

> 1. 최초 생성된 인스턴스 t1은 0x100 객체 주소를 가진다.
> 2. 두번째 생성된 인스턴스 t2는 0x200 객체 주소를 가진다.
> 3. t2에 t1의 주소값을 재할당해주어 인스턴스 t2가 가진 객체 값들은 더 이상 사용할 수 없게 된다.
> 4. 가비지 컬렉터로부터 사용 불가능한 0x200주소를 가진 객체는 불필요한 메모리를 낭비하므로 삭제되어진다.
> 5. 가비지 컬렉터 (GC)는 주기적으로 메모리 낭비를 체크한다. 따라서, 일일이 개발자가 적용하지 않더라도 불필요한 객체를 삭제해준다.
> ** GC에 대해 더 깊이 공부해보기

<br>

#### 6-8 클래스의 다른 정의

##### 1. 데이터와 함수의 결합

- 변수 - 하나의 데이터를 저장할 수 있는 공간
- 배열 - 동일한 타입에 여러 데이터를 저장할 수 있는 공간
- 구조체 - 타입에 관계없이 서로 관련된 데이터를 저장할 수 있는 공간
- 클래스 (구조체 + 함수) 데이터와 함수의 결합

##### 2. 클래스 - 사용자 정의 타입
- 개발자가 직접 새로운 타입을 정의할 수 있다.
- 서로 관련된 값을 묶어 하나의 타입으로 정의한다.

```
class Time {
	int hour;
	int minute;
	int second;
}

// ==========================================================

int hour;
int minute;
int second;

// int 타입 hour, minute, secound 변수를 가진 클래스의 인스턴스
Time t = new Time();

// ==========================================================

int hour1, hour2, hour3;
int minute1, minute2, minute3;
int second1, second2, second3;

// int 타입 hour, minute, secound 변수를 가진 클래스의 인스턴스 
Time t1 = new Time();
Time t2 = new Time();
Time t3 = new Time();

// ======================================================

int[] hour = new int[3];
int[] minute = new int[3];
int[] second = new int[3];

// int 타입 hour, minute, secound 변수를 가진 클래스의 배열 인스턴스
Time[] t = new Time[3];

t[0] = new Time();
t[1] = new Time();
t[2] = new Time();
```

<br>

#### 6.9 변수와 메서드

1. 선언위치에 따른 변수의 종류

- 변수의 선언위치가 변수의 종류와 범위를 결정한다.


```
{
	// 클래스 영역
	int iv;			// 인스턴스 변수
	static int cv;	// 클래스 변수 (static 변수, 공유 변수)
	
	void method() {
		// 메서드 영역
		int lv = 0;	// 지역변수
	}
}

```

- 클래스 변수(클래스 영역): 클래스가 메모리에 올라갈 때 생성
	- 같은 클래스이 모든 인스턴스들이 공유하는 변수
	- 인스턴스 생성없이 클래스이름.클래스변수명으로 접근
	- 클래스가 로딩될 때 생성, 프로그램 종료시 소멸
	
- 인스턴스 변수 (클래스 영역): 인스턴스 생성시 생성
	- 각 인스턴스의 개별적인 저장공간. 인스턴스마다 다른 값 저장 가능
	- 인스턴스 생성 후 참조변수.인스턴스변수명으로 접근
	- 인스턴스 생성시 생성되며 참조변수가 없으면 가비지컬렉터에 의해 자동삭제됨

- 지역변수 (메서드 영역): 변수 선언문 수행시 생성
	- 메서드 내 선언, 메서드 종료시 소멸
	- 조건문, 반복문의 블럭 내에 선언된 지역변수는 블럭을 벗어나면 소멸

```	
// 카드 클래스
// 무늬, 숫자, 폭, 높이 총 4개의 속성을 갖는다.
// 기능...

class Card {
	// 4개의 멤버 변수를 갖는다.
	String kind;
	int number;
	
	// 폭과 높이는 고정된 값
	static int width = 100;
	static int height = 250;
}
```

<br>

2. JVM 메모리 구조

- Method Area - 클래스 정보와 클래스 변수가 저장되는 곳

- Call Stack 
	- 메서드의 작업공간. 메서드 호출시 메서드 수행에 필요한 메모리공간 할당받음
	- 메서드가 종료되면 사용하던 메모리 반환

> 메서드가 호출되면 수행에 필요한 메모리를 스택에 할당받는다.
> 메서드가 수행을 마치면 사용했던 메모리 반환한다.
> 호출 스택 제일 위 메서드가 현재 실행 중인 메서드이다.
> 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

<br>

```
class CallStackTest {
	public static void main (String[] args) {
		firstMethod();
	}
	
	static void firstMethod() {
		secondMethod();
	}
	
	static void secondMethod() {
		System.out.println("secondMethod()");
	}
}

// println
// secondMethod
// firstMethod
// main
```

<br>

- Heap

> 인스턴스가 생성되는 공간
> new 연산자에 의해 생성되는 배열과 객체는 모두 여기에 생성
